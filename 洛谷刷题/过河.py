# 21：10

# 显然是动态规划
# 第一步先描述问题
# 青蛙从0开始出发，每次跳的距离属于[S,T]，落地的位置有石子即为踩到了石子
# 终点的坐标为L，注意不是L-1。
# 求青蛙最少需要踩的石子个数。
#
#
# 第二步，状态转移方程
# 之后考虑现在青蛙站在下标为i的位置上，它跳一步的距离在S~T之间
# 那么，dp[i] = min{第一步跳距离x踩到的石子数+从i+x位置跳到终点最少踩的石子数 for x in [S,T]}
#
#
# 第三步，初始化
# 显然是个线性的动态规划问题。
# 定义dp[i]表示从i~L最少要踩几颗石子
# 显然如果i+T>=L，也就是跳最远的距离可以直接跳出去，那么就一定不会踩石子。
# 所以i>=L-T的dp[i]都等于0
#
#
# 第四步，完善细节：
# 需要从后向前遍历i，从L到L-T的dp都为0
# 再往前的，（i<L-T）对于x在range(S,T+1),if i+x的位置有石子，值为1+dp[i+x]。注意跳跃是接上的。
#     if 没有，值为dp[i+x]
#     ，最后输出dp[0]

L = int(input())
S,T,M=tuple(map(int,input().split()))

